import {
  MeshBVH,
  convertToBufferType,
  isSharedArrayBufferSupported
} from "./chunk-WF4PNXL2.js";
import {
  Box3,
  BufferAttribute
} from "./chunk-N54QU66Z.js";

// node_modules/three-mesh-bvh/src/workers/utils/WorkerBase.js
var WorkerBase = class {
  constructor(worker) {
    this.name = "WorkerBase";
    this.running = false;
    this.worker = worker;
    this.worker.onerror = (e) => {
      if (e.message) {
        throw new Error(`${this.name}: Could not create Web Worker with error "${e.message}"`);
      } else {
        throw new Error(`${this.name}: Could not create Web Worker.`);
      }
    };
  }
  runTask() {
  }
  generate(...args) {
    if (this.running) {
      throw new Error("GenerateMeshBVHWorker: Already running job.");
    }
    if (this.worker === null) {
      throw new Error("GenerateMeshBVHWorker: Worker has been disposed.");
    }
    this.running = true;
    const promise = this.runTask(this.worker, ...args);
    promise.finally(() => {
      this.running = false;
    });
    return promise;
  }
  dispose() {
    this.worker.terminate();
    this.worker = null;
  }
};

// node_modules/three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js
var GenerateMeshBVHWorker = class extends WorkerBase {
  constructor() {
    const worker = new Worker(new URL("./generateMeshBVH.worker.js", import.meta.url), { type: "module" });
    super(worker);
    this.name = "GenerateMeshBVHWorker";
  }
  runTask(worker, geometry, options = {}) {
    return new Promise((resolve, reject) => {
      if (geometry.getAttribute("position").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) {
        throw new Error("GenerateMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");
      }
      worker.onerror = (e) => {
        reject(new Error(`GenerateMeshBVHWorker: ${e.message}`));
      };
      worker.onmessage = (e) => {
        const { data } = e;
        if (data.error) {
          reject(new Error(data.error));
          worker.onmessage = null;
        } else if (data.serialized) {
          const { serialized, position: position2 } = data;
          const bvh = MeshBVH.deserialize(serialized, geometry, { setIndex: false });
          const boundsOptions = Object.assign({
            setBoundingBox: true
          }, options);
          geometry.attributes.position.array = position2;
          if (geometry.index) {
            geometry.index.array = serialized.index;
          } else {
            const newIndex = new BufferAttribute(serialized.index, 1, false);
            geometry.setIndex(newIndex);
          }
          if (boundsOptions.setBoundingBox) {
            geometry.boundingBox = bvh.getBoundingBox(new Box3());
          }
          resolve(bvh);
          worker.onmessage = null;
        } else if (options.onProgress) {
          options.onProgress(data.progress);
        }
      };
      const index = geometry.index ? geometry.index.array : null;
      const position = geometry.attributes.position.array;
      const transferable = [position];
      if (index) {
        transferable.push(index);
      }
      worker.postMessage({
        index,
        position,
        options: {
          ...options,
          onProgress: null,
          includedProgressCallback: Boolean(options.onProgress),
          groups: [...geometry.groups]
        }
      }, transferable.map((arr) => arr.buffer).filter((v) => typeof SharedArrayBuffer === "undefined" || !(v instanceof SharedArrayBuffer)));
    });
  }
};

// node_modules/three-mesh-bvh/src/workers/ParallelMeshBVHWorker.js
var DEFAULT_WORKER_COUNT = typeof navigator !== "undefined" ? navigator.hardwareConcurrency : 4;
var _ParallelMeshBVHWorker = class extends WorkerBase {
  constructor() {
    const worker = new Worker(new URL("./parallelMeshBVH.worker.js", import.meta.url), { type: "module" });
    super(worker);
    this.name = "ParallelMeshBVHWorker";
    this.maxWorkerCount = Math.max(DEFAULT_WORKER_COUNT, 4);
    if (!isSharedArrayBufferSupported()) {
      throw new Error("ParallelMeshBVHWorker: Shared Array Buffers are not supported.");
    }
  }
  runTask(worker, geometry, options = {}) {
    return new Promise((resolve, reject) => {
      if (geometry.getAttribute("position").isInterleavedBufferAttribute || geometry.index && geometry.index.isInterleavedBufferAttribute) {
        throw new Error("ParallelMeshBVHWorker: InterleavedBufferAttribute are not supported for the geometry attributes.");
      }
      worker.onerror = (e) => {
        reject(new Error(`ParallelMeshBVHWorker: ${e.message}`));
      };
      worker.onmessage = (e) => {
        const { data } = e;
        if (data.error) {
          reject(new Error(data.error));
          worker.onmessage = null;
        } else if (data.serialized) {
          const { serialized, position: position2 } = data;
          const bvh = MeshBVH.deserialize(serialized, geometry, { setIndex: false });
          const boundsOptions = {
            setBoundingBox: true,
            ...options
          };
          geometry.attributes.position.array = position2;
          if (geometry.index) {
            geometry.index.array = serialized.index;
          } else {
            const newIndex = new BufferAttribute(serialized.index, 1, false);
            geometry.setIndex(newIndex);
          }
          if (boundsOptions.setBoundingBox) {
            geometry.boundingBox = bvh.getBoundingBox(new Box3());
          }
          resolve(bvh);
          worker.onmessage = null;
        } else if (options.onProgress) {
          options.onProgress(data.progress);
        }
      };
      const index = geometry.index ? geometry.index.array : null;
      const position = geometry.attributes.position.array;
      worker.postMessage({
        operation: "BUILD_BVH",
        maxWorkerCount: this.maxWorkerCount,
        index: convertToBufferType(index, SharedArrayBuffer),
        position: convertToBufferType(position, SharedArrayBuffer),
        options: {
          ...options,
          onProgress: null,
          includedProgressCallback: Boolean(options.onProgress),
          groups: [...geometry.groups]
        }
      });
    });
  }
};
var ParallelMeshBVHWorker = class {
  constructor() {
    if (isSharedArrayBufferSupported()) {
      return new _ParallelMeshBVHWorker();
    } else {
      console.warn("ParallelMeshBVHWorker: SharedArrayBuffers not supported. Falling back to single-threaded GenerateMeshBVHWorker.");
      const object = new GenerateMeshBVHWorker();
      object.maxWorkerCount = DEFAULT_WORKER_COUNT;
      return object;
    }
  }
};
export {
  ParallelMeshBVHWorker
};
//# sourceMappingURL=three-mesh-bvh_src_workers_ParallelMeshBVHWorker__js.js.map
